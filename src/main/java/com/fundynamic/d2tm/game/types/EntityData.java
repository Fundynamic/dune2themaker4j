package com.fundynamic.d2tm.game.types;

import com.fundynamic.d2tm.game.entities.EntityType;
import com.fundynamic.d2tm.game.entities.entitiesdata.EntitiesData;
import com.fundynamic.d2tm.game.entities.entitiesdata.EntitiesDataReader;
import com.fundynamic.d2tm.game.entities.entitybuilders.EntityBuilderType;
import com.fundynamic.d2tm.math.Coordinate;
import com.fundynamic.d2tm.math.MapCoordinate;
import com.fundynamic.d2tm.math.Vector2D;
import com.fundynamic.d2tm.utils.StringUtils;
import org.newdawn.slick.Image;

import java.util.ArrayList;
import java.util.List;

import static com.fundynamic.d2tm.game.map.Cell.TILE_SIZE;

/**
 * <h1>Overview</h1>
 * This is an object representation of an Entity. The {@link EntitiesData} class contains
 * all objects after reading the rules.ini file. The interpretation of the file and the construction of an {@link EntityData} class
 * is done by the {@link EntitiesDataReader}.
 *
 * <h2>Structures</h2>
 * <p>Example piece of rules.ini file for structures:</p>
 * <pre>
 *     [STRUCTURES]
 *
 *      [STRUCTURES/CONSTYARD]
 *      image=structures/2x2_constyard.png
 *      hitpoints=2000
 *      width=64
 *      height=64
 *      sight=5
 *      explosion=BOOM
 *
 * </pre>
 * <p>The structure has a reference to EXPLOSIONS which is implemented by (#{@link com.fundynamic.d2tm.game.entities.particle.Particle}</p>
 */
public class EntityData {

    public static final String UNKNOWN = "UNKNOWN";

    public String name;             // the name used in the INI file (ie [QUAD] without [])

    // Kind of entity it reflects
    public EntityType type;

    // Build related
    public EntityBuilderType entityBuilderType = EntityBuilderType.NONE;

    public float buildTimeInSeconds = 1.0F;
    public float buildRange = 0F;
    public int buildCost = -1;      // cost to build this
    public Image buildIcon;         // build icon
    public String buildList = "";

    public Image image;             // base image
    public Image barrelImage;       // barrelImage (top image)
    private int facings;

    private int width;              // in pixels
    private int height;             // in pixels
    private int widthInCells;       // in cells, derived from pixels
    private int heightInCells;      // in cells, derived from pixels

    public int sight;

    public float moveSpeed;         // the speed a unit moves: value is pixels in seconds.
    public float turnSpeed;         // the speed a unit turns: value is facing angles in seconds. < 1 means the value is times per second
    public float turnSpeedCannon;   // the speed a unit's barrel turns: value is facing angles in seconds. < 1 means the value is times per second

    public float attackRate;        // the speed a unit attacks: < 1 means the value is times per second
    public float attackRange;       // the range for a unit to attack in pixels

    public String weaponId = UNKNOWN;
    public int damage;

    public int hitPoints;           // initial hitPoints when spawned

    public String explosionId = UNKNOWN;

    public float animationSpeed;    // in frames per second, for animating

    public String key;              // key used in HashMap

    public boolean recolor;         // if 'true' then the particle will be recolored (into team color) before spawned

    // for turning
    private float chop = -1f;
    private float halfChop = -1f;

    public boolean isHarvester;

    public String soundId = UNKNOWN;          // for playing sound if required

    public EntityData() {
    }

    public EntityData(int width, int height, int sight) {
        setWidth(width);
        setHeight(height);
        this.sight = sight;
    }

    public Image getFirstImage() {
        return image.getSubImage(0, 0, width, height);
    }

    public void setWidth(int width) {
        this.width = width;
        widthInCells = (int) Math.ceil((float) width / TILE_SIZE);
    }

    public void setHeight(int height) {
        this.height = height;
        heightInCells = (int) Math.ceil((float) height / TILE_SIZE);
    }

    public int getWidth() {
        return width;
    }

    public int getHeight() {
        return height;
    }

    public int getWidthInCells() {
        return widthInCells;
    }

    public int getHeightInCells() {
        return heightInCells;
    }

    @Override
    public String toString() {
        return "EntityData{" +
                "chop=" + chop +
                ", halfChop=" + halfChop +
                ", type=" + type +
                ", image=" + image +
                ", barrelImage=" + barrelImage +
                ", width=" + width +
                ", height=" + height +
                ", widthInCells=" + widthInCells +
                ", heightInCells=" + heightInCells +
                ", sight=" + sight +
                ", moveSpeed=" + moveSpeed +
                ", turnSpeed=" + turnSpeed +
                ", turnSpeedCannon=" + turnSpeedCannon +
                ", attackRate=" + attackRate +
                ", attackRange=" + attackRange +
                ", hitPoints=" + hitPoints +
                ", facings=" + facings +
                ", damage=" + damage +
                ", explosionId='" + explosionId + '\'' +
                ", weaponId='" + weaponId + '\'' +
                ", animationSpeed=" + animationSpeed +
                ", key='" + key + '\'' +
                ", recolor=" + recolor +
                '}';
    }

    public boolean hasFacings() {
        return facings > 0;
    }

    public void setFacingsAndCalculateChops(int facings) {
        this.facings = facings;
        this.chop = 360F / facings;
        this.halfChop = chop / 2F;
    }

    public float getChop() {
        return chop;
    }

    public float getHalfChop() {
        return halfChop;
    }

    public int getFacings() {
        return facings;
    }

    public boolean hasExplosionId() {
        return !UNKNOWN.equals(explosionId);
    }

    public boolean hasWeaponId() {
        return !UNKNOWN.equals(weaponId);
    }

    public boolean hasSoundId() {
        return !UNKNOWN.equals(soundId);
    }

    public String getWeaponIdKey() {
        return constructKey(EntityType.PROJECTILE, weaponId);
    }

    public String getExplosionIdKey() {
        return constructKey(EntityType.PARTICLE, explosionId);
    }

    public static String constructKey(EntityType entityType, String id) {
        return entityType.toString() + "-" + id;
    }

    /**
     * This takes time into account as well. This makes the distance of moveSpeed equivalent to 1 second.
     *
     * @param deltaInSeconds
     * @return
     */
    public float getRelativeMoveSpeed(float deltaInSeconds) {
        return moveSpeed * deltaInSeconds;
    }

    /**
     * See @link getRelativeMoveSpeed
     * @param deltaInSeconds
     * @return
     */
    public float getRelativeTurnSpeed(float deltaInSeconds) {
        return getRelativeSpeed(turnSpeed, deltaInSeconds);
    }

    public static float getRelativeSpeed(float speed, float deltaInSeconds) {
        return speed * deltaInSeconds;
    }

    public float getRelativeAttackRate(float deltaInSeconds) {
        return getRelativeSpeed(attackRate, deltaInSeconds);
    }

    public boolean isTypeStructure() {
        return EntityType.STRUCTURE.equals(this.type);
    }

    public boolean isTypeUnit() {
        return EntityType.UNIT.equals(this.type);
    }

    public boolean isTypeParticle() {
        return EntityType.PARTICLE.equals(this.type);
    }

    public boolean isTypeSuperPower() {
        return EntityType.SUPERPOWER.equals(this.type);
    }

    public boolean isTypeProjectile() {
        return EntityType.PROJECTILE.equals(this.type);
    }

    /**
     * Given a topLeftX and topLeftY coordinate, calculate all cells that are being occupied by this
     * entity and return that as a list of coordinates. These coordinates are top-left coordinates of cells.
     *
     * @return
     */
    public List<MapCoordinate> getAllCellsAsCoordinates(Coordinate coordinate) {
        List<MapCoordinate> result = new ArrayList<>(widthInCells * heightInCells);
        for (int x = 0; x < widthInCells; x++) {
            for (int y = 0; y < heightInCells; y++) {
                int vecX = coordinate.getXAsInt() + (x * TILE_SIZE);
                int vecY = coordinate.getYAsInt() + (y * TILE_SIZE);
                result.add(Coordinate.create(vecX, vecY).toMapCoordinate());
            }
        }
        return result;
    }

    /**
     * Given a topLeftX and topLeftY coordinate, calculate all cells that are being occupied by this
     * entity and return that as a list of coordinates.
     *
     * The coordinates are corrected to be centered within a cell.
     *
     * @return
     */
    public List<Coordinate> getAllCellsAsCenteredCoordinates(Coordinate coordinate) {
        List<MapCoordinate> result = getAllCellsAsCoordinates(coordinate);

        List<Coordinate> centered = new ArrayList<>(result.size());
        Vector2D halfCell = Vector2D.create(TILE_SIZE / 2, TILE_SIZE / 2);
        for (MapCoordinate resultCoordinate : result) {
            centered.add(resultCoordinate.toCoordinate().add(halfCell));
        }
        return centered;
    }

    public Vector2D getHalfSize() {
        return Vector2D.create(width / 2, height / 2);
    }

    public Vector2D getSize() {
        return Vector2D.create(width, height);
    }

    public List<String> getEntityDataKeysToBuild() {
        return StringUtils.splitLenientToList(buildList, ",");
    }
}
